<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Cadreur.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Cadreur.html">Cadreur</a></li>
            
                <li><a href="..&#x2F;classes/Cadreur_DIRECTIONS.html">Cadreur_DIRECTIONS</a></li>
            
                <li><a href="..&#x2F;classes/CadreurContainer.html">CadreurContainer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Cadreur.html">Cadreur</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: Cadreur.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 *	@module Cadreur
 *&#x2F;

&#x2F;**	Used for create the container&#x27;s name *&#x2F;
var nb_cadreur_container = 65;

&#x2F;**
 *	Enum of directions
 *	@class Cadreur_DIRECTIONS
 *&#x2F;
Cadreur_DIRECTIONS = {VERTICAL: 1, HORIZONTAL: 2};

&#x2F;**
 *	Container of boxes or containers.
 *
 *	Used in internal by Cadreur.
 *	@param {Cadreur_DIRECTIONS} direction The direction of the container
 *	@class CadreurContainer
 *	@constructor
 *&#x2F;
function CadreurContainer(direction)
{
	this.name = String.fromCharCode(nb_cadreur_container++);

	this.boxes = [];
	this.direction = direction;
}

&#x2F;**
 *  Create a layout for a HTML element.
 *
 *	@class Cadreur
 *	@constructor
 *	@param rootNode The HTML element in which is the layout
 *	@param direction The default direction of the layout (vertical or horizontal)
 *&#x2F;
function Cadreur(rootNode, direction)
{
	if (!(rootNode instanceof HTMLElement)) alert(&quot;The rootNode parameter is not a HTML element&quot;);
	this.rootNode = rootNode;

	this.rootContainer = new CadreurContainer(direction); 

	&#x2F;&#x2F; Manage size changes
	this.manageSize();
	$(window).resize(this, this.manageSize);

	this.dragged_box = null;
	this.drag_enabled = true;
	this.front = true;

	&#x2F;&#x2F; Manage boxes&#x27;s drag and drop
	var jNode = $(this.rootNode);
	this.visual_drag = document.createElement(&#x27;div&#x27;);
	this.visual_drag.id = &#x27;visual_drag&#x27;;
	this.visual_drag.style.display = &#x27;none&#x27;;
	this.rootNode.appendChild(this.visual_drag);

	var obj = this;
	jNode.mousedown(function(e){
		if (!obj.front &amp;&amp; obj.drag_enabled &amp;&amp; obj.dragged_box === null) {
			&#x2F;&#x2F; Recovery of the dragged box
			var jdragged_box = jNode.find(&#x27;.boxdiv.identifiee&#x27;);

			jdragged_box.addClass(&#x27;dragged&#x27;);
			obj.dragged_box = jdragged_box[0];
			obj.visual_drag.style.display = &#x27;block&#x27;;
			obj.visual_drag.style.top = e.clientY-13+&#x27;px&#x27;;
			obj.visual_drag.style.left = e.clientX-13+&#x27;px&#x27;;
			obj.visual_drag.style.background = jdragged_box.css(&#x27;background&#x27;);
		}
	});

	var jbody = $(document.body);
	jbody.mouseup(function(){
		if (obj.dragged_box){
			
			&#x2F;&#x2F; If the box didn&#x27;t find a place to live
			if (!obj.dragged_box.style.top &amp;&amp; !obj.dragged_box.style.left)
				&#x2F;&#x2F; We could find a place 
				obj.addBoxInBestPlace(obj.dragged_box);
			else
				$(obj.dragged_box).removeClass(&#x27;dragged&#x27;);
		
			obj.visual_drag.style.display = &#x27;none&#x27;;
			obj.dragged_box = null;
		}
	});

	&#x2F;&#x2F; Handling mouse position
	jbody.mousemove(function(e){
		if (obj.drag_enabled &amp;&amp; obj.dragged_box){
			obj.visual_drag.style.top = e.clientY-13+&#x27;px&#x27;;
			obj.visual_drag.style.left = e.clientX-13+&#x27;px&#x27;;
		}
		obj.hover(e.pageX, e.pageY);
	});
};


Cadreur.prototype = 
{
	&#x2F;**
	 *	Create a new box for the layout.
	 *
	 *	The box have two faces. Frontface (default), and backface.
	 *
	 *	@method createBox
	 *	@return {Object} An object : {box, front, back}
	 *&#x2F;
	createBox: function()
	{
		var div = document.createElement(&#x27;div&#x27;);

		var front = document.createElement(&#x27;div&#x27;);
		front.className = &#x27;front&#x27;;
		div.appendChild(front);

		var back = document.createElement(&#x27;div&#x27;);
		back.className = &#x27;back&#x27;;

		if (this.front)
			back.style.display = &#x27;none&#x27;;
		else
			front.style.display = &#x27;none&#x27;;

		div.appendChild(back);
		return {box: this.transformBox(div), front: front, back: back};
	},

	&#x2F;**
	 *	Attach the box to the layout.
	 *
	 *	createBox doesn&#x27;t do this.
	 *
	 *	@method transformBox
	 *	@param {HTMLElement} div The box to attach
	 *	@return	{HTMLElement} The same box, but attached
	 *&#x2F;
	transformBox: function(div)
	{
		$(div).addClass(&#x27;box boxdiv&#x27;);
		this.rootNode.appendChild(div);
		return div;
	},

	&#x2F;**
	 *	Disable the drag&#x27;n&#x27;drop action for the div in the back side.
	 * 
	 *	@param {HTMLElement} div The div in which disable the drag
	 *&#x2F;
	disableDrag: function(div)
	{
		var jdiv = $(div);
		var obj = this;
		jdiv.mousedown(function(){
			obj.drag_enabled = false;
		});
		jdiv.mouseup(function(){
			obj.drag_enabled = true;
		});
	},

	&#x2F;**
	 *	Place the box in the layout.
	 *
	 *	@method addBox
	 *	@param {HTMLElement|CadreurContainer} box The box to place.
	 *	@param {CadreurContainer|Null} container The optionnal container where to place the box.
	 *&#x2F;
	addBox: function(box, container)
	{
		this.rootContainer.addBox(box, container ? container : this.rootContainer);
	},

	&#x2F;**
	 *	Toggle the display of boxes&#x27;s sides.
	 *
	 *	@method toggleFrontMode
	 *	@param {Function|Null} action Action to execute during the change 
	 *	@param {Number}	duration Duration of the animation	
	 *&#x2F;
	toggleFrontMode: function(action, duration)
	{
		this.front = !this.front;
		var jnode = $(this.rootNode);

		var boxes = jnode.find(&#x27;.boxdiv&#x27;);
		boxes.addClass(&#x27;flipped_animation&#x27;);
		var obj = this;
		setTimeout(function() {
			boxes.find(obj.front ? &#x27;.back&#x27; : &#x27;.front&#x27;).hide();
			boxes.find(obj.front ? &#x27;.front&#x27; : &#x27;.back&#x27;).show();
			boxes.removeClass(&#x27;flipped_animation&#x27;);
			if (action) action();
		}, duration == null ? 600 : duration);

	},

	&#x2F;**
	 *	Update the layout size.
	 *
	 *	@method manageSize
	 *	@param {Cadreur} obj Optionnal reference for replacing this.
	 *&#x2F;
	manageSize: function(obj)
	{
		var obj = obj == null ? this : obj.data;
		obj.width = $(obj.rootNode).width();
		obj.height = $(obj.rootNode).height();
		obj.equilibrate();
	},

	&#x2F;**
	 *	Exec the callback function for each box in the layout.
	 *
	 *	The passed arguments for the function are :
	 *		* The box
	 *		* x position of the box
	 *		* y position of the box
	 *		* width of the box
	 *		* height of the box
	 *		* stack of containers in which the box is
	 *
	 *	@method processing
	 *	@param {function} callback The function to execute.
	 *&#x2F;
	processing: function(callback)
	{
		this.rootContainer.processing(0, 0, this.width, this.height, callback);
	},

	&#x2F;**
	 *	Place every box to his place.
	 *
	 *	@method equilibrate
	 *&#x2F;
	equilibrate: function()
	{
		var marge = 3;
		this.processing(
			function (box, x, y, width, height) {
				y = y + marge + &#x27;px&#x27;;
				x = x + marge + &#x27;px&#x27;;
				height = height - marge - marge + &#x27;px&#x27;;
				width = width - marge - marge + &#x27;px&#x27;;

				if (box.style.top != y) box.style.top = y;
				if (box.style.left != x) box.style.left = x;
				if (box.style.height != height) box.style.height = height;
				if (box.style.width != width) box.style.width = width;

				&#x2F;&#x2F; Even the hidden boxes are showed
				if (box.style.display === &#x27;none&#x27;) box.style.display = &#x27;block&#x27;;
			});
	},

	&#x2F;**
	 *	Manage the mouse location above the layout.
	 *
	 *	The processing is about the drag and drop.
	 *
	 *	@method hover
	 *	@protected
	 *	@param {Number} mouse_x
	 *	@param {Number} mouse_y
	 *&#x2F;
	hover: function(mouse_x, mouse_y)
	{
		var obj = this;
		var div = this.dragged_box;
		this.processing(
			function (box, x, y, width, height, containers) {
				var box_mouse_x = mouse_x - x;
				var box_mouse_y = mouse_y -y;
				&#x2F;&#x2F; If the mouse is over the current box
				if (box_mouse_x &gt;= 0 &amp;&amp; box_mouse_x &lt;= width &amp;&amp;
					box_mouse_y &gt;= 0 &amp;&amp; box_mouse_y &lt;= height)
				{
					&#x2F;&#x2F; If this is not the dragged mouse, is just an identifed box
					if (!div)
						$(box).addClass(&#x27;identifiee&#x27;);

					&#x2F;&#x2F; If the box is the dragged box, we have to do nothing here 
					if (!div || div === box) return;

					&#x2F;** Fast method using vector product
					 * for determine if a point is in a triangle.
					 *&#x2F;
					var in_triangle = function(a_x, a_y, b_x, b_y, c_x, c_y, p_x, p_y) {
						var geoprog = function(a_x, a_y, b_x, b_y, c_x, c_y) {
							return (a_x * (b_y - c_y) + b_x * (c_y - a_y) + c_x * (a_y - b_y)) &gt;= 0;
						};
						var p1 = geoprog(a_x, a_y, b_x, b_y, p_x, p_y);
						var p2 = geoprog(b_x, b_y, c_x, c_y, p_x, p_y);
						var p3 = geoprog(c_x, c_y, a_x, a_y, p_x, p_y);

						return p1 &gt; 0 &amp;&amp; p2 &gt; 0 &amp;&amp; p3 &gt; 0 || p1 &lt; 0 &amp;&amp; p2 &lt; 0 &amp;&amp; p3 &lt; 0;
					};

					&#x2F;**
					 *	Add the dragged box in the good container.
					 *
					 *	@param containers Stack of containers
					 *	@param position Top&#x2F;Right&#x2F;Bottom&#x2F;Left	
					 *	@param target	The neighbor box
					 *
					 *	@return the result of the correct placement, or nothing
					 *&#x2F;
					var addBox = function(containers, position, target){

						var container = containers.pop();

						&#x2F;&#x2F; If no one container is good, do nothing
						if (!container)
							return;

						&#x2F;&#x2F; Try to find a good container in which add the box 
						if (container.direction === Cadreur_DIRECTIONS.VERTICAL)
						{
							if (position === 0)
								return obj.rootContainer.addBoxTop(div, target, container);
							else if (position === 2)
								return obj.rootContainer.addBoxBottom(div, target, container);
						}
						else
						{
							if (position === 1)
								return obj.rootContainer.addBoxRight(div, target, container);
							else if (position === 3)
								return obj.rootContainer.addBoxLeft(div, target, container);
						}

						&#x2F;&#x2F; If no container is good, try with the container from above
						return arguments.callee(containers, position, container);
					} 

					&#x2F;&#x2F; Locate where is the mouse in the box
					var box_center_x = x + width &#x2F; 2;
					var box_center_y = y + height &#x2F; 2;
					var position = -1;
					if (in_triangle(x, y, x+width, y,
						box_center_x, box_center_y, mouse_x, mouse_y))
						position = 0; &#x2F;&#x2F; TOP
					else if (in_triangle(x+width, y, x+width, y+height,
						box_center_x, box_center_y, mouse_x, mouse_y))
						position = 1; &#x2F;&#x2F; RIGHT
					else if (in_triangle(x, y+height,
						box_center_x, box_center_y, x+width, y+height,
						mouse_x, mouse_y))
						position = 2; &#x2F;&#x2F; BOTTOM
					else if (in_triangle(x, y, box_center_x, box_center_y,
						x, y+height, mouse_x, mouse_y))
						position = 3; &#x2F;&#x2F; LEFT

					&#x2F;&#x2F; Try to add the box 
					addBox(containers, position, box);

					&#x2F;&#x2F; And show to the user the wonderful result
					obj.equilibrate();

				} else {
					$(box).removeClass(&#x27;identifiee&#x27;);
				}
			});
	},

	&#x2F;**
	 *	Add a box in the best container.
	 *
	 *	@method addBoxInBestPlace
	 *	@param {HTMLElement|CadreurContainer} box The box to place
	 *&#x2F;
	addBoxInBestPlace: function(box) {
		var best_container = this.rootContainer;

		&#x2F;&#x2F; Find the last container with no more children
		this.processing(
			function (box, x, y, width, height, containers) {
				var container = containers[containers.length -1];
				if (container.boxes.length &lt;= best_container.boxes.length)
					best_container = container;
			});

		this.addBox(box, best_container);
		this.equilibrate();
	}, 

	&#x2F;**
	 *	Change the layout&#x27;s disposition.
	 *
	 *	@method changeLayout
	 *	@param new_layout	The new layout (really)
	 *&#x2F;
	changeLayout: function (new_layout) {
		new_layout(this, $(this.rootNode).find(&#x27;.boxdiv&#x27;));
		this.equilibrate();
	},

	&#x2F;**
	 *	Some usefull layouts
	 *	@property
	 *&#x2F;
	layouts:
	{
		&#x2F;** Simple vertical layout *&#x2F;
		vertical: function(obj, boxes) {
			obj.rootContainer = new CadreurContainer(Cadreur_DIRECTIONS.VERTICAL);
			for (var i = 0; i &lt; boxes.length; ++i)
				obj.addBox(boxes[i]);

		},

		&#x2F;** Simple horizontal layout *&#x2F;
		horizontal: function(obj, boxes) {
			obj.rootContainer = new CadreurContainer(Cadreur_DIRECTIONS.HORIZONTAL);
			for (var i = 0; i &lt; boxes.length; ++i)
				obj.addBox(boxes[i]);
		},

		&#x2F;** Vertical split layout *&#x2F;
		verticalSplit: function(obj, boxes) {
			obj.rootContainer = new CadreurContainer(Cadreur_DIRECTIONS.HORIZONTAL);
			if (boxes.length &gt; 0)
			{
				obj.addBox(boxes[0]);
				if (boxes.length &gt; 1)
				{
					var container = new CadreurContainer(Cadreur_DIRECTIONS.VERTICAL);
					obj.addBox(container);
					for (var i = 1; i &lt; boxes.length; ++i)
						obj.addBox(boxes[i], container);
				}
			}

		},

		&#x2F;** Horizontal split layout *&#x2F;
		horizontalSplit: function(obj, boxes) {
			obj.rootContainer = new CadreurContainer(Cadreur_DIRECTIONS.VERTICAL);
			if (boxes.length &gt; 0)
			{
				obj.addBox(boxes[0]);
				if (boxes.length &gt; 1)
				{
					var container = new CadreurContainer(Cadreur_DIRECTIONS.HORIZONTAL);
					obj.addBox(container);
					for (var i = 1; i &lt; boxes.length; ++i)
						obj.addBox(boxes[i], container);
				}
			}
		},

		&#x2F;** Grid layout *&#x2F;
		grid: function(obj, boxes) {
			var nb_boxes = boxes.length;

			&#x2F;&#x2F; The size of grid is calculed just one time
			&#x2F;&#x2F; It&#x27;s intersting to execute this function when the number
			&#x2F;&#x2F; of boxes have changed
			var sqrt = Math.sqrt(nb_boxes);
			var lines = Math.ceil(sqrt);
			var columns = Math.round(sqrt);

			obj.rootContainer = new CadreurContainer(Cadreur_DIRECTIONS.VERTICAL);
			var cpt = 0;
			for (var i = 0; i &lt; lines; ++i) {
				var line = new CadreurContainer(Cadreur_DIRECTIONS.HORIZONTAL);
				obj.addBox(line);
				for (var j = 0; j &lt; columns &amp;&amp; cpt &lt; nb_boxes; ++j)
					obj.addBox(boxes[cpt++], line);
			}
		},

		&#x2F;** Complex and weird layout *&#x2F;
		multi: function(obj, boxes) {
			var nb_boxes = boxes.length;
			obj.rootContainer = new CadreurContainer(Cadreur_DIRECTIONS.VERTICAL);
			var cpt = 0;

			if (nb_boxes &gt; cpt) {
				obj.addBox(boxes[cpt++]);
				if (nb_boxes &gt; cpt) {
					var container = new CadreurContainer(Cadreur_DIRECTIONS.HORIZONTAL);
					obj.addBox(container);
					obj.addBox(boxes[cpt++], container);
					if (nb_boxes &gt; cpt) {
						obj.addBox(boxes[cpt++], container);
						if (nb_boxes &gt; cpt) {
							var container_vertical = new CadreurContainer(Cadreur_DIRECTIONS.VERTICAL);
							obj.addBox(container_vertical, container);
							for (var i = 0; i &lt; 3 &amp;&amp; cpt &lt; nb_boxes; ++i)
								obj.addBox(boxes[cpt++], container_vertical);

							for (var i = 0; i &lt; 2 &amp;&amp; cpt &lt; nb_boxes; ++i)
								obj.addBox(boxes[cpt++], container);

							while (cpt &lt; nb_boxes)
								obj.addBox(boxes[cpt++]);
						}
					}
				}
			}
		}
	}
}

&#x2F;**
 *	@class CadreurContainer
 *&#x2F;
CadreurContainer.prototype = 
{
	&#x2F;**
	 *	@method toString
	 *	@return {String}
	 *&#x2F;
	toString: function()
	{
		var str = &quot;[&quot;+this.name+&quot;: &quot;;

		for (var i = 0; i &lt; this.boxes.length; ++i)
		{
			var box = this.boxes[i];
			if (box instanceof CadreurContainer)
				str += box;
			else
				str += box.getAttribute(&#x27;id&#x27;);
			str += &quot;, &quot;;

		}

		str = str.slice(0, str.length -2);
		str += &#x27;]&#x27;;

		return str;
	},

	&#x2F;**
	 *	Add the box in the target container.
	 *
	 *	The target container could be a child. This function is recursive.
	 *
	 *	A function could be called when the box is added. The container is
	 *		passed by parameters, and the box isn&#x27;t added automatically. 
	 *
	 *	@method addBox
	 *	@protected
	 *	@param {HTMLElement|CadreurContainer} box The box to add
	 *	@param {CadreurContainer} container The container in which add the box
	 *	@param {Function|Null} action An optionnal function to execute when the box is added
	 *&#x2F; 
	addBox: function(box, container, action)
	{
		var remove = function(array, elem)
		{
		    var match = -1;

		    while( (match = array.indexOf(elem)) &gt; -1 )
		        array.splice(match, 1);

	        return array;
		};

		for (var i = 0; i &lt; this.boxes.length; ++i)
		{
			var ibox = this.boxes[i];

			if (ibox instanceof CadreurContainer)
			{
				ibox.addBox(box, container, action);
				&#x2F;&#x2F; Removing empty containers (for eliminate empty areas)
				if (ibox.boxes.length === 0)
					this.boxes = remove(this.boxes, ibox);
			}

			&#x2F;&#x2F; If we find the box in another container, we change his location
			if (ibox !== container &amp;&amp; ibox === box)
				this.boxes = remove(this.boxes, box);

		}

		if (this === container)
		{
			if (action)
				action(this);
			else
				this.boxes.push(box);
		}
	},

	&#x2F;**
	 *	Add the box above the target.
	 *
	 *	@method addBoxTop
	 *	@param {HTMLElement|CadreurContainer} box
	 *	@param {HTMLElement|CadreurContainer} target
	 *	@param {CadreurContainer} container
	 *&#x2F;
	addBoxTop: function(box, target, container)
	{
		var obj  = this;
		this.addBox(box,container, function(container) {
			var boxes = container.boxes;
			boxes.splice(boxes.indexOf(target), 0, box);			
		}); 
	},

	&#x2F;**
	 *	Add the box right to the target.
	 *
	 *	@method addBoxRight
	 *	@param {HTMLElement|CadreurContainer} box
	 *	@param {HTMLElement|CadreurContainer} target
	 *	@param {CadreurContainer} container
	 *&#x2F;
	addBoxRight: function(box, target, container)
	{
		this.addBox(box,container, function(container) {
			var boxes = container.boxes;
			boxes.splice(boxes.indexOf(target)+1, 0, box);			
		}); 
	},

	&#x2F;**
	 *	Add the box below the target.
	 *
	 *	@method addBoxBottom
	 *	@param {HTMLElement|CadreurContainer} box
	 *	@param {HTMLElement|CadreurContainer} target
	 *	@param {CadreurContainer} container
	 *&#x2F;
	addBoxBottom: function(box, target, container)
	{
		this.addBox(box,container, function(container) {
			var boxes = container.boxes;
			boxes.splice(boxes.indexOf(target)+1, 0, box);			
		}); 
	},

	&#x2F;**
	 *	Add the box left to the target.
	 *
	 *	@method addBoxLeft
	 *	@param {HTMLElement|CadreurContainer} box
	 *	@param {HTMLElement|CadreurContainer} target
	 *	@param {CadreurContainer} container
	 *&#x2F;
	addBoxLeft: function(box, target, container)
	{
		this.addBox(box,container, function(container) {
			var boxes = container.boxes;
			boxes.splice(boxes.indexOf(target), 0, box);			
		}); 
	},

	&#x2F;**
	 *	Exec the callback function for each box in the layout.
	 *
	 *	@method processing
	 *	@protected	
	 *	@param {Number} jmp_x X position of the box
	 *	@param {Number} jmp_y Y position of the box
	 *	@param {Number} width Width of the box
	 *	@param {Number} height Height of the box
	 *	@param {Function} callback The callback to execute (more info in Box_layout.processing)
	 *	@param {Array} containers Stack of containers in which the boxes are
	 *&#x2F;	
	processing: function(jmp_x, jmp_y, width, height, callback, containers)
	{
		var height_jmp = 0;
		var width_jmp = 0;
		var nb_boxes = this.boxes.length;

		if (this.direction === Cadreur_DIRECTIONS.VERTICAL)
		{
			height = Math.ceil(height &#x2F; nb_boxes);
			height_jmp = height;
		} else
		{
			width = Math.ceil(width &#x2F; nb_boxes);
			width_jmp = width;
		}

		&#x2F;&#x2F; Manage the stack of containers
		if (containers instanceof Array)
			containers.push(this);
		else
			containers = [this];

		for (var i = 0; i &lt; nb_boxes; ++i) {

			var x = jmp_x + i * width_jmp;
			var y = jmp_y + i * height_jmp;

			var box = this.boxes[i];

			&#x2F;&#x2F; Recursive call of the processing function
			&#x2F;&#x2F; The slice function is very important, lot of time was wasted here
			if (box instanceof CadreurContainer)
				box.processing(x, y, width, height, callback, containers.slice(0));
			else
				callback(box, x, y, width, height, containers);

		}
	}

};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
